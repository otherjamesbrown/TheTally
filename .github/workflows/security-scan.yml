name: Security Scan

on:
  push:
    branches: [ develop, feature/* ]
  pull_request:
    branches: [ develop, main ]
  schedule:
    # Run security scan daily at 2 AM UTC
    - cron: '0 2 * * *'

jobs:
  security-scan:
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      contents: read
      actions: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload Trivy scan results to GitHub Security tab
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'
      
      - name: Check for secrets in code
        uses: trufflesecurity/trufflehog@main
        with:
          path: ./
          base: ${{ github.event_name == 'schedule' && '' || 'main' }}
          head: ${{ github.event_name == 'schedule' && '' || 'HEAD' }}
          extra_args: --debug --only-verified
      
      - name: Run Bandit security linter for Python (Development)
        run: |
          echo "üîç Running Bandit security linter for Python code (Development mode)..."
          pip install bandit
          # Run bandit with development-friendly settings
          bandit -r backend/ -f json -o bandit-results.json -ll -x backend/tests/ || true
          
          # Only fail on HIGH severity issues in development
          if jq '.results[] | select(.issue_severity == "HIGH")' bandit-results.json | grep -q "HIGH"; then
            echo "‚ùå HIGH severity security issues found"
            jq '.results[] | select(.issue_severity == "HIGH")' bandit-results.json
            exit 1
          fi
          
          echo "‚úÖ Development security scan completed (only HIGH severity issues block development)"
      
      - name: Check for hardcoded secrets with Gitleaks
        uses: gitleaks/gitleaks-action@v2
        with:
          config-path: .gitleaks.toml
          fail-on-findings: true
          no-git: false
          verbose: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Validate .env.example exists
        run: |
          if [ ! -f ".env.example" ]; then
            echo "‚ùå .env.example file not found"
            exit 1
          fi
          echo "‚úÖ .env.example file exists"
      
      - name: Check .gitignore for secrets patterns
        run: |
          echo "üîç Checking .gitignore for secrets protection..."
          
          required_patterns=(
            ".env*"
            "*.key"
            "*.pem"
            "secrets.json"
            "credentials.json"
            "service-account.json"
          )
          
          for pattern in "${required_patterns[@]}"; do
            if ! grep -q "$pattern" .gitignore; then
              echo "‚ùå Missing pattern in .gitignore: $pattern"
              exit 1
            fi
          done
          
          echo "‚úÖ .gitignore has required secrets patterns"
      
      - name: Security scan summary
        if: always()
        run: |
          echo "## üîí Security Scan Summary"
          echo "‚úÖ Trivy vulnerability scan completed"
          echo "‚úÖ TruffleHog secrets scan completed"
          echo "‚úÖ Bandit Python security scan completed"
          echo "‚úÖ Hardcoded secrets check completed"
          echo "‚úÖ .gitignore validation completed"
          echo ""
          echo "Check the Security tab for detailed results."
